#pragma once

#include "user_os.h" // Прослойка между методами конкретной операционной системы пользователя.
#include "project_config.h" // Файл с разрешением на компиляцию данного блока.

#ifdef MODULE_BUTTONS_BASE

namespace button {

/*!
 * Данная структура описывает механизм
 * поведения в случае возникновения
 * какой-либо ситуации.
 * Пример: произошло короткое
 * нажатие, долгое нажатие,
 * клавишу отпустили и т.д.
 */
struct event {
    /*!
     * Указатель на семафор, который будет
     * отдан при возникновении события.
     * Может быть nullptr, тогда при
     * возникновении события не будет
     * выдачи семафора.
     */
    USER_OS_STATIC_BIN_SEMAPHORE *s;
    
    /*!
     * Указатель на очередь, в которую
     * будет положено значение из переменной
     * v в случае возникновения события.
     * Может быть nullptr, тогда при
     * возникновении события сообщение в
     * очередь положено не будет.
     */
    USER_OS_STATIC_QUEUE *q;
    uint8_t v;
};

/*!
 * Флаги состояния  одной клавиши.
 * Структура является системной.
 */
struct status {
    /*!
     * Флаг состояния нажатия до текущей проверки (окончание предыдущей).
     */
    bool press;
    
    /*!
     * Флаг состояния проверки на дребезг:
     * true - идет (еще идет), false - пройдена успешно.
     */
    bool bounce;
    
    /*!
     * Флаг события "произошло длительное нажатие":
     * true - произошло, false - нет.
     */
    bool event_long_click;
    
    /*!
     * Оставшееся время до окончания проверки на дребезг (в мс).
     */
    uint32_t bounce_time;
    
    /*!
     * Сколько прошло времени с момента нажатия клавиши
     * (идет начиная с проверки дребезга).
     */
    uint32_t button_long_click_time;
};

struct one_button_cfg {
    /*!
     * Уникальный идентификатор клавиши.
     * При обращении к физическому уровню
     * по нему будет осуществляться запрос
     * состояния конкретной клавиши.
     *
     * Данный идентификатор задается
     * пользователем и может иметь
     * любое неповторяющееся в пределах
     * одного модуля значение.
     */
    uint8_t id;
    
    /*!
     * Время отслеживания дребезга контактов.
     * Количество мс, для стабилизации
     * нажатия (защита от дребезга).
     * Указывается в миллисекундах.
     */
    uint8_t stabilization_time_ms;
    
    /*!
     * Отслеживание долгого нажатия.
     * Время нажатия, после которого
     * кнопка считается долго зажатой.
     * В миллисекундах.
     * Если тут 0, то долгое нажатие
     * не детектируется.
     */
    uint8_t long_press_detection_time_sec;
    
    /*!
     * Кнопку нажали (прошла проверку дребезга).
     */
    button::event press;
    
    /*!
     * Кнопку отпустили до того, как
     * прошел период longPressDetectionTimeS.
     * Если период longPressDetectionTimeS
     * был задан как 0, то после любого по
     * времени нажатия будет выдача
     * этого события.
     */
    button::event click;
    
    /*!
     * Кнопку держат дольше
     * longPressDetectionTimeS.
     */
    button::event long_press;
    
    /*!
     * Кнопку отпустили после того, как
     * прошел период longPressDetectionTimeS.
     * Если период longPressDetectionTimeS
     * был задан как 0, то по окончании
     * нажатия будет выдано событие
     * click.
     */
    button::event long_click;
};

struct base_cfg {
    /*!
     * Пауза между опросами всех кнопок.
     */
    uint8_t task_delay_ms;
    
    /*!
     * Приоритет задачи, работающий с кнопками.
     */
    uint8_t task_prio;
    
    /*!
     * Массив конфигураций клавиш.
     */
    one_button_cfg *cfg_array;
    
    /*!
     * Количество кнопок (размер массива).
     */
    uint8_t cfg_array_size;
    
    /*!
     * Метод возвращает текущее состояние
     * клавиши (нажата/отпущена).
     * В качестве id используется число
     * полученное из структуры конфигурации
     * кнопки (поле id).
     */
    bool (*get_button_state) (uint8_t id);
};

class base {
public:
    base (const base_cfg *const cfg);

private:
    static void task (void *obj);

private:
    /*!
     *`Обработка клавиши в случае,
     *`если клавиша в данный момент нажата.
     */
    void process_press (uint32_t b_number);
    
    /*!
     * бработка клавиши в случае,
     * если клавиша в данный момент отпущена.
     */
    void process_not_press (uint32_t b_number);

    /*!
     * Метод производит отправку сообщения в очередь
     * и/или выдачу семафора по событию: клавиша была нажата.
     */
    void send_message_event_press (one_button_cfg *p_st);
    
    /*!
     * Метод производит отправку сообщения в очередь и/или
     * выдачу семафора по событию: зафиксировано долгое нажатие.
     */
    void send_message_event_long_press (one_button_cfg *p_st);
    
    /*!
     * Метод производит отправку сообщения в очередь и/или выдачу
     * семафора по событию: произошел отпуск клавиши после того,
     * как было зафиксировано долгое нажатие
     */
    void send_message_event_long_click (one_button_cfg *p_st);
    
    /*!
     * Метод производит отправку сообщения в очередь и/или выдачу
     * семафора по событию: произошел отпуск клавиши до того,
     * как было зафиксировано длительное нажатие
     */
    void send_message_event_click (one_button_cfg *p_st);
    
private:
    const base_cfg *const cfg;
    status *s;

private:
    const static uint32_t TASK_STACK_SIZE = 400;

private:
    USER_OS_STATIC_STACK_TYPE task_stack[button::base::TASK_STACK_SIZE];
    USER_OS_STATIC_TASK_STRUCT_TYPE task_struct;
    
};

}

#endif
